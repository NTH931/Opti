/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxError", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownError", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessError", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxError", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownError", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessError", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxError", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownError", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessError", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxError", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownError", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessError", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxError", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownError", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessError", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxError", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownError", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessError", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 366:
/***/ ((module, exports, __webpack_require__) => {

var __webpack_unused_export__;
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Bootstrap.ts
/* eslint-disable no-var */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    __webpack_unused_export__ = ({ value: true });
    __webpack_unused_export__ = void 0;
    var Opti = globalThis.Opti || {};
    __webpack_unused_export__ = Opti;
    globalThis.Opti = Opti;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 688:
/***/ (function() {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Opti;
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxError(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxError(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxError(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return result;
    }
    Opti.generateID = generateID;
    Opti.ColorizedSyntaxError = function (message) {
        const err = new Error(message);
        Object.setPrototypeOf(err, Opti.ColorizedSyntaxError.prototype);
        err.name = "ColorizedSyntaxError";
        return err;
    };
    Opti.UnknownError = function (message) {
        const err = new Error(message);
        err.name = "UnknownError";
        Object.setPrototypeOf(err, Opti.UnknownError.prototype);
        return err;
    };
    Opti.AccessError = function (message) {
        const err = new Error(message);
        err.name = "AccessError";
        Object.setPrototypeOf(err, Opti.AccessError.prototype);
        return err;
    };
    Opti.CustomError = function (name, message) {
        const err = new Error(message);
        err.name = name;
        Object.setPrototypeOf(err, Opti.CustomError.prototype);
        return err;
    };
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomError("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownError = Opti.UnknownError;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessError = Opti.AccessError;
    globalThis.CustomError = Opti.CustomError;
    globalThis.ColorizedSyntaxError = Opti.ColorizedSyntaxError;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedError", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxError", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownError", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessError", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
            this.stack = "";
            this.message = "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message, cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();
(function (Opti) {
    function atDate(year, monthIndex, date, hours, minutes, seconds, ms) {
        return new Date(year, monthIndex, date, hours, minutes, seconds, ms).getTime();
    }
    Opti.atDate = atDate;
    function fromTime(time, year, monthIndex, date) {
        return new Date(year, monthIndex, date, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    }
    Opti.fromTime = fromTime;
    function clone(object, deep = true) {
        if (object === null || typeof object === "undefined") {
            return object;
        }
        else if (typeof object !== "object" && typeof object !== "symbol" && typeof object !== "function") {
            return object;
        }
        const shallowClone = () => Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        const deepClone = (obj, seen = new WeakMap()) => {
            if (obj === null || typeof obj !== "object")
                return obj;
            if (seen.has(obj))
                return seen.get(obj);
            // Preserve prototype
            const cloned = Array.isArray(obj)
                ? []
                : Object.create(Object.getPrototypeOf(obj));
            seen.set(obj, cloned);
            if (obj instanceof Date)
                return new Date(obj.getTime());
            if (obj instanceof RegExp)
                return new RegExp(obj);
            if (obj instanceof Map) {
                obj.forEach((v, k) => cloned.set(deepClone(k, seen), deepClone(v, seen)));
                return cloned;
            }
            if (obj instanceof Set) {
                obj.forEach(v => cloned.add(deepClone(v, seen)));
                return cloned;
            }
            if (ArrayBuffer.isView(obj))
                return new obj.constructor(obj);
            if (obj instanceof ArrayBuffer)
                return obj.slice(0);
            for (const key of Reflect.ownKeys(obj)) {
                cloned[key] = deepClone(obj[key], seen);
            }
            return cloned;
        };
        return deep ? deepClone(object) : shallowClone();
    }
    Opti.clone = clone;
    ;
    function repeat(iterator) {
        for (let i = 0; i < this; i++) {
            iterator(i);
        }
    }
    Opti.repeat = repeat;
    ;
    function unique() {
        return [...new Set(this)];
    }
    Opti.unique = unique;
    ;
    function chunk(chunkSize) {
        if (chunkSize <= 0)
            throw new TypeError("`chunkSize` cannot be a number below 1");
        const newArr = [];
        let tempArr = [];
        this.forEach(val => {
            tempArr.push(val);
            if (tempArr.length === chunkSize) {
                newArr.push(tempArr);
                tempArr = []; // Reset tempArr for the next chunk
            }
        });
        // Add the remaining elements in tempArr if any
        if (tempArr.length) {
            newArr.push(tempArr);
        }
        return newArr;
    }
    Opti.chunk = chunk;
    ;
    function remove(finder) {
        return this.replace(finder, "");
    }
    Opti.remove = remove;
    ;
    function removeAll(finder) {
        if (finder instanceof RegExp) {
            if (!finder.flags.includes("g")) {
                finder = new RegExp(finder.source, finder.flags + "g");
            }
        }
        return this.replaceAll(finder, "");
    }
    Opti.removeAll = removeAll;
    ;
    const origionalRandom = Math.random;
    Opti.random = (minOrMax, max) => {
        if (isDefined(minOrMax) && isDefined(max)) {
            return origionalRandom() * (max - minOrMax) + minOrMax;
        }
        else if (isDefined(minOrMax)) {
            return origionalRandom() * minOrMax;
        }
        else
            return origionalRandom();
    };
    function isDefined(obj) {
        return typeof obj !== "undefined";
    }
    Opti.isDefined = isDefined;
    function forEach(object, iterator) {
        for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                iterator(key, object[key]);
            }
        }
    }
    Opti.forEach = forEach;
    ;
    function capitalize() {
        const i = this.search(/\S/);
        return i === -1 ? this : this.slice(0, i) + this.charAt(i).toUpperCase() + this.slice(i + 1);
    }
    Opti.capitalize = capitalize;
    ;
    function parseFile(file, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileContent = yield fetch(file).then(res => res.json());
            if (!receiver) {
                return fileContent;
            }
            return receiver(fileContent);
        });
    }
    Opti.parseFile = parseFile;
    ;
    const origionallog = console.log;
    function log(colorize, ...data) {
        const text = data.map(val => typeof val === "string" ? val : JSON.stringify(val)).join(" ");
        origionallog(Opti.Colorize `${text}`);
    }
    Opti.log = log;
})(Opti || (Opti = {}));
(function (Opti) {
    function addEventListenerEnum(type, listener, options) {
        for (const el of this) {
            if (el instanceof Element) {
                el.addEventListener(type, listener, options);
            }
        }
    }
    Opti.addEventListenerEnum = addEventListenerEnum;
    function addClassList(elClass) {
        for (const el of this) {
            el.addClass(elClass);
        }
    }
    Opti.addClassList = addClassList;
    ;
    function removeClassList(elClass) {
        for (const el of this) {
            el.removeClass(elClass);
        }
    }
    Opti.removeClassList = removeClassList;
    ;
    function toggleClassList(elClass) {
        for (const el of this) {
            el.toggleClass(elClass);
        }
    }
    Opti.toggleClassList = toggleClassList;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    function type(val) {
        var _a;
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const typeOf = typeof val;
        if (typeOf === "function") {
            return `Function:${val.name || "<anonymous>"}(${val.length})`;
        }
        let typeName = Opti.capitalize.call(Object.prototype.toString.call(val).slice(8, -1));
        const ctor = (_a = val.constructor) === null || _a === void 0 ? void 0 : _a.name;
        if (ctor && ctor !== typeName) {
            typeName = ctor;
        }
        const len = val.length;
        if (typeof len === "number" && Number.isFinite(len)) {
            typeName += `(${len})`;
        }
        else if (val instanceof Map || val instanceof Set) {
            typeName += `(${val.size})`;
        }
        else if (val instanceof Date && !isNaN(val.getTime())) {
            typeName += `:${val.toISOString().split("T")[0]}`;
        }
        else if (typeName === "Object") {
            typeName += `(${Object.keys(val).length})`;
        }
        return typeName;
    }
    Opti.type = type;
    ;
    // Mapping of style keywords to ANSI escape codes for terminal formatting
    const styles = {
        red: "\x1b[31m",
        orange: "\x1b[38;5;208m", // extended ANSI orange
        yellow: "\x1b[33m",
        green: "\x1b[32m",
        cyan: "\x1b[36m",
        blue: "\x1b[34m",
        purple: "\x1b[35m",
        pink: "\x1b[38;5;205m", // extended ANSI pink
        underline: "\x1b[4m",
        bold: "\x1b[1m",
        strikethrough: "\x1b[9m",
        italic: "\x1b[3m",
        emphasis: "\x1b[3m", // alias for italic
        reset: "\x1b[0m",
    };
    function Colorize(strings, ...values) {
        // Combine all parts of the template string with interpolated values
        let input = strings.reduce((acc, str, i) => { var _a; return acc + str + ((_a = values[i]) !== null && _a !== void 0 ? _a : ""); }, "");
        // Replace shorthand syntax for bold and underline
        // Replace {_..._} and {*...*} with {underline:...}, and {**...**} with {bold:...}
        input = input
            .replace(/\{_([^{}]+)_\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\{\*\*([^{}]+)\*\*\}/g, (_, content) => `{bold:${content}}`)
            .replace(/\{\*([^{}]+)\*\}/g, (_, content) => `{underline:${content}}`)
            .replace(/\\x1b/g, '\x1b');
        // Replace escaped braces \{ and \} with placeholders so they are not parsed as tags
        input = input.replace(/\\\{/g, "__ESCAPED_OPEN_BRACE__").replace(/\\\}/g, "__ESCAPED_CLOSE_BRACE__");
        let output = ""; // Final output string with ANSI codes
        const stack = []; // Stack to track open styles for proper nesting
        let i = 0; // Current index in input
        while (i < input.length) {
            // Match the start of a style tag like {red: or {(dynamic ANSI code):
            const openMatch = input.slice(i).match(/^\{([a-zA-Z]+|\([^)]+\)):/);
            if (openMatch) {
                let tag = openMatch[1];
                if (tag.startsWith("(") && tag.endsWith(")")) {
                    // Dynamic ANSI escape code inside parentheses
                    tag = tag.slice(1, -1); // remove surrounding parentheses
                    stack.push("__dynamic__");
                    output += tag; // Insert raw ANSI code directly
                }
                else {
                    if (!styles[tag]) {
                        throw new Opti.ColorizedSyntaxException(`Unknown style: ${tag}`);
                    }
                    stack.push(tag);
                    output += styles[tag];
                }
                i += openMatch[0].length; // Move index past the opening tag
                continue;
            }
            // Match closing tag '}'
            if (input[i] === "}") {
                if (!stack.length) {
                    // No corresponding opening tag
                    throw new Opti.ColorizedSyntaxException(`Unexpected closing tag at index ${i}`);
                }
                stack.pop(); // Close the last opened tag
                output += styles.reset; // Reset styles
                // Re-apply all remaining styles still on the stack
                for (const tag of stack) {
                    // Reapply dynamic codes as-is, else mapped styles
                    output += tag === "__dynamic__" ? "" : styles[tag];
                }
                i++; // Move past closing brace
                continue;
            }
            // Append normal character to output, but restore escaped braces if needed
            if (input.startsWith("__ESCAPED_OPEN_BRACE__", i)) {
                output += "{";
                i += "__ESCAPED_OPEN_BRACE__".length;
                continue;
            }
            if (input.startsWith("__ESCAPED_CLOSE_BRACE__", i)) {
                output += "}";
                i += "__ESCAPED_CLOSE_BRACE__".length;
                continue;
            }
            output += input[i++];
        }
        // If stack is not empty, we have unclosed tags
        if (stack.length) {
            const lastUnclosed = stack[stack.length - 1];
            throw new Opti.ColorizedSyntaxException(`Missing closing tag for: ${lastUnclosed}`);
        }
        // Ensure final reset for safety
        return output + styles.reset;
    }
    Opti.Colorize = Colorize;
    function isEmpty(val) {
        // Generic type checking
        // eslint-disable-next-line eqeqeq
        if (val == null || val === false || val === "")
            return true;
        // Number checking
        if (typeof val === "number")
            return val === 0 || Number.isNaN(val);
        // Array checking
        if (Array.isArray(val) && val.length === 0)
            return true;
        // Map, Set, and weak variant checks
        if (val instanceof Map || val instanceof Set || val instanceof WeakMap || val instanceof WeakSet) {
            return val.size === 0; // size check works for these types
        }
        // Object checking
        if (typeof val === 'object') {
            const proto = Object.getPrototypeOf(val);
            const isPlain = proto === Object.prototype || proto === null;
            return isPlain && Object.keys(val).length === 0;
        }
        return false;
    }
    Opti.isEmpty = isEmpty;
    function createEventListener(triggers, callback) {
        const originals = triggers.map(fn => fn);
        triggers.forEach((originalFn, i) => {
            function wrapper(...args) {
                const result = originals[i].apply(this, args);
                callback(...triggers.map((_, j) => j === i ? result : undefined));
                return result;
            }
            ;
            // Replace global function by matching the actual function object
            if (typeof window !== "undefined") {
                for (const key in window) {
                    if (window[key] === originalFn) {
                        window[key] = wrapper;
                        return; // stop after replacement
                    }
                }
            }
            console.warn("Cannot replace function:", originalFn);
        });
    }
    Opti.createEventListener = createEventListener;
    function generateID() {
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%&*_-";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        // Type assertion to add the brand
        return Object.freeze(result);
    }
    Opti.generateID = generateID;
})(Opti || (Opti = {}));
(function (Opti) {
    class Exception extends Error {
        constructor(name, message = "", cause = "") {
            var _a;
            super();
            this._message = message;
            this._cause = cause;
            this._name = name !== null && name !== void 0 ? name : "Exception";
            this._internalStack = (_a = new Error().stack) !== null && _a !== void 0 ? _a : "";
        }
        get name() {
            return this._name;
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        throw() {
            throw this;
        }
        getStackTrace() {
            return this._internalStack;
        }
        toString() {
            return `${this._name}: ${this._message}\r\n${this._internalStack}`;
        }
    }
    Opti.Exception = Exception;
    class RuntimeException {
        constructor(message = "", cause = "") {
            this._message = message;
            this._cause = cause;
        }
        get name() {
            return "RuntimeException";
        }
        getMessage() {
            return this._message;
        }
        getCause() {
            return this._cause;
        }
        toString() {
            return `RuntimeException: ${this._message}`;
        }
    }
    Opti.RuntimeException = RuntimeException;
    class NotImplementedException extends Exception {
        constructor(message = "Function not implimented yet", cause) {
            super("NotImplementedException", message, cause);
        }
    }
    Opti.NotImplementedException = NotImplementedException;
    class ColorizedSyntaxException extends Exception {
        constructor(message, cause) {
            super("ColorizedSyntaxException", message, cause);
            Object.setPrototypeOf(this, ColorizedSyntaxException.prototype);
        }
    }
    Opti.ColorizedSyntaxException = ColorizedSyntaxException;
    class UnknownException extends Exception {
        constructor(message, cause) {
            super("UnknownException", message, cause);
            Object.setPrototypeOf(this, UnknownException.prototype);
        }
    }
    Opti.UnknownException = UnknownException;
    class AccessException extends Exception {
        constructor(message, cause) {
            super("AccessException", message, cause);
            Object.setPrototypeOf(this, AccessException.prototype);
        }
    }
    Opti.AccessException = AccessException;
    class CustomException extends Exception {
        constructor(name, message, cause) {
            super(name, message, cause);
            Object.setPrototypeOf(this, CustomException.prototype);
        }
    }
    Opti.CustomException = CustomException;
})(Opti || (Opti = {}));
(function (Opti) {
    function addBoundListener(type, listener, timesOrCondition, options) {
        if (typeof timesOrCondition === "number") {
            if (timesOrCondition <= 0)
                return;
            let repeatCount = timesOrCondition; // Default to 1 if no repeat option provided
            const onceListener = (event) => {
                listener.call(this, event);
                repeatCount--;
                if (repeatCount <= 0) {
                    this.removeEventListener(type, onceListener, options);
                }
            };
            this.addEventListener(type, onceListener, options);
        }
        else {
            if (timesOrCondition.call(this))
                return;
            const onceListener = (event) => {
                if (timesOrCondition.call(this)) {
                    this.removeEventListener(type, onceListener, options);
                    return;
                }
                listener.call(this, event);
            };
            this.addEventListener(type, onceListener, options);
        }
    }
    Opti.addBoundListener = addBoundListener;
    ;
    function addEventListeners(listenersOrTypes, callback, options) {
        if (Array.isArray(listenersOrTypes)) {
            for (const type of listenersOrTypes) {
                this.addEventListener(String(type), callback, options);
            }
        }
        else {
            for (const [event, listener] of Object.entries(listenersOrTypes)) {
                if (listener) {
                    this.addEventListener(String(event), listener, options);
                }
            }
        }
    }
    Opti.addEventListeners = addEventListeners;
    ;
    function delegateEventListener(type, delegator, listener, options) {
        this.addEventListener(type, function (e) {
            const target = e.target;
            if (!target)
                return;
            let selector;
            if (typeof delegator === "string") {
                selector = delegator;
            }
            else {
                selector = ""; // fallback
            }
            const matchedEl = target.closest(selector);
            if (matchedEl &&
                (!(this instanceof Element) || this.contains(matchedEl))) {
                listener.call(matchedEl, e);
            }
        }, options);
    }
    Opti.delegateEventListener = delegateEventListener;
})(Opti || (Opti = {}));
(function (Opti) {
    function hasText(text) {
        if (typeof text === "string") {
            return this.txt().includes(text);
        }
        else {
            return text.test(this.txt());
        }
    }
    Opti.hasText = hasText;
    function addClass(elClass) {
        this.classList.add(elClass);
    }
    Opti.addClass = addClass;
    function removeClass(elClass) {
        this.classList.remove(elClass);
    }
    Opti.removeClass = removeClass;
    function toggleClass(elClass) {
        this.classList.toggle(elClass);
    }
    Opti.toggleClass = toggleClass;
    function hasClass(elClass) {
        return this.classList.contains(elClass);
    }
    Opti.hasClass = hasClass;
    function css(key, value) {
        const css = this.style;
        if (!key) {
            // Return all styles
            const result = {};
            for (let i = 0; i < css.length; i++) {
                const prop = css[i];
                if (prop) {
                    result[prop] = css.getPropertyValue(prop).trim();
                }
            }
            return result;
        }
        if (typeof key === "string") {
            if (value === undefined) {
                // Get one value
                return css.getPropertyValue(key).trim();
            }
            else {
                // Set one value
                if (key in css) {
                    css.setProperty(toKebabCase(key), value.toString());
                }
            }
        }
        else {
            // Set multiple
            for (const [prop, val] of Object.entries(key)) {
                if (val !== null && val !== undefined) {
                    css.setProperty(toKebabCase(prop), val.toString());
                }
            }
        }
    }
    Opti.css = css;
    ;
    function getParent() {
        return this.parentElement;
    }
    Opti.getParent = getParent;
    ;
    function getAncestor(arg) {
        // Case 1: numeric level
        if (typeof arg === "number") {
            let node = this;
            for (let i = 0; i < arg; i++) {
                if (!(node === null || node === void 0 ? void 0 : node.parentNode))
                    return null;
                node = node.parentNode;
            }
            return node;
        }
        // Case 2: selector string
        const selector = arg;
        let el = this instanceof Element ? this : this.parentElement;
        while (el) {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    Opti.getAncestor = getAncestor;
    function createChildren(elements) {
        const element = document.createElement(elements.element);
        if (elements.id) {
            element.id = elements.id;
        }
        if (elements.className) {
            if (Array.isArray(elements.className)) {
                element.classList.add(...elements.className);
            }
            else {
                element.classList.add(elements.className);
            }
        }
        // Assign additional attributes dynamically
        for (const key in elements) {
            if (!['element', 'id', 'className', 'children'].includes(key)) {
                const value = elements[key];
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                }
                else if (Array.isArray(value)) {
                    element.setAttribute(key, value.join(' ')); // Convert array to space-separated string
                }
            }
        }
        // Recursively create children
        if (elements.children) {
            if (Array.isArray(elements.children)) {
                elements.children.forEach(child => {
                    // Recursively create child elements
                    element.createChildren(child);
                });
            }
            else {
                // Recursively create a single child element
                element.createChildren(elements.children);
            }
        }
        this.appendChild(element);
    }
    Opti.createChildren = createChildren;
    ;
    function tag(newTag) {
        if (!newTag) {
            return this.tagName.toLowerCase();
        }
        const newElement = document.createElement(newTag);
        // Copy attributes
        Array.from(this.attributes).forEach(attr => {
            newElement.setAttribute(attr.name, attr.value);
        });
        // Copy dataset
        Object.entries(this.dataset).forEach(([key, value]) => {
            newElement.dataset[key] = value;
        });
        // Copy inline styles
        newElement.style.cssText = this.style.cssText;
        // Copy classes
        newElement.className = this.className;
        // Copy child nodes
        while (this.firstChild) {
            newElement.appendChild(this.firstChild);
        }
        // Transfer listeners (if you have a system for it)
        if (this._eventListeners instanceof Map) {
            const listeners = this._eventListeners;
            listeners.forEach((fns, type) => {
                fns.forEach(fn => newElement.addEventListener(type, fn));
            });
            newElement._eventListeners = new Map(listeners);
        }
        // Optional: Copy properties (if you have custom prototype extensions)
        for (const key in this) {
            // Skip built-in DOM properties and functions
            if (!(key in newElement) &&
                typeof this[key] !== "function") {
                try {
                    newElement[key] = this[key];
                }
                catch (_a) {
                    // Some props might be readonly — safely ignore
                }
            }
        }
        this.replaceWith(newElement);
        return newElement;
    }
    Opti.tag = tag;
    ;
    function html(input) {
        return input !== undefined ? (this.innerHTML = input) : this.innerHTML;
    }
    Opti.html = html;
    ;
    function text(text, ...input) {
        var _a, _b, _c;
        // If text is provided, update the textContent
        if (text !== undefined) {
            if (typeof text === "string") {
                input.unshift(text); // Add the text parameter to the beginning of the input array
                const joined = input.join(" "); // Join all the strings with a space
                // Replace "textContent" if it's found in the joined string (optional logic)
                this.textContent = joined.includes("textContent")
                    ? joined.replace("textContent", (_a = this.textContent) !== null && _a !== void 0 ? _a : "")
                    : joined;
            }
            else {
                this.textContent = text((_b = this.textContent) !== null && _b !== void 0 ? _b : "");
            }
        }
        // Return the current textContent if no arguments are passed
        return (_c = this.textContent) !== null && _c !== void 0 ? _c : "";
    }
    Opti.text = text;
    ;
    function show() {
        this.css("visibility", "visible");
    }
    Opti.show = show;
    ;
    function hide() {
        this.css("visibility", "hidden");
    }
    Opti.hide = hide;
    ;
    function toggle() {
        if (this.css("visibility") === "visible" || this.css("visibility") === "") {
            this.hide();
        }
        else {
            this.show();
        }
    }
    Opti.toggle = toggle;
    ;
    function find(selector) {
        return this.querySelector(selector); // Returns a single Element or null
    }
    Opti.find = find;
    ;
    function findAll(selector) {
        return this.querySelectorAll(selector); // Returns a single Element or null
    }
    Opti.findAll = findAll;
    ;
    function getChildren() {
        return this.childNodes;
    }
    Opti.getChildren = getChildren;
    ;
    function getSiblings(inclusive) {
        const siblings = Array.from(this.parentNode.childNodes);
        if (inclusive) {
            return siblings; // Include current node as part of siblings
        }
        else {
            return siblings.filter(node => !node.isSameNode(this));
        }
    }
    Opti.getSiblings = getSiblings;
    ;
    function serialize() {
        const formData = new FormData(this); // Create a FormData object from the form
        // Create an array to hold key-value pairs
        const entries = [];
        // Use FormData's forEach method to collect form data
        formData.forEach((value, key) => {
            entries.push([key, value.toString()]);
        });
        // Convert the entries into a query string
        return entries
            .map(([key, value]) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        })
            .join('&'); // Join the array into a single string, separated by '&'
    }
    Opti.serialize = serialize;
    ;
    function elementCreator() {
        return new Opti.HTMLElementCreator(this);
    }
    Opti.elementCreator = elementCreator;
    ;
    function cut() {
        const clone = document.createElementNS(this.namespaceURI, this.tagName);
        // Copy all attributes
        for (const attr of Array.from(this.attributes)) {
            clone.setAttribute(attr.name, attr.value);
        }
        // Deep copy child nodes (preserves text, elements, etc.)
        for (const child of Array.from(this.childNodes)) {
            clone.appendChild(child.cloneNode(true));
        }
        // Optionally copy inline styles (not always needed if using setAttribute above)
        if (this instanceof HTMLElement && clone instanceof HTMLElement) {
            clone.style.cssText = this.style.cssText;
        }
        this.remove(); // Remove original from DOM
        return clone;
    }
    Opti.cut = cut;
})(Opti || (Opti = {}));
(function (Opti) {
    function ready(callback) {
        document.addEventListener("DOMContentLoaded", callback);
    }
    Opti.ready = ready;
    function leaving(callback) {
        document.addEventListener("unload", (e) => callback.call(document, e));
    }
    Opti.leaving = leaving;
    function bindShortcut(shortcut, callback) {
        document.addEventListener('keydown', (event) => {
            const keyboardEvent = event;
            keyboardEvent.keys = shortcut.split("+");
            const keys = shortcut
                .trim()
                .toLowerCase()
                .split("+");
            // Separate out the modifier keys and the actual key
            const modifiers = keys.slice(0, -1);
            const finalKey = keys[keys.length - 1];
            const modifierMatch = modifiers.every((key) => {
                if (key === 'ctrl' || key === 'control')
                    return keyboardEvent.ctrlKey;
                if (key === 'alt')
                    return keyboardEvent.altKey;
                if (key === 'shift')
                    return keyboardEvent.shiftKey;
                if (key === 'meta' || key === 'windows' || key === 'command')
                    return keyboardEvent.metaKey;
                return false;
            });
            // Check that the pressed key matches the final key
            const keyMatch = finalKey === keyboardEvent.key.toLowerCase();
            if (modifierMatch && keyMatch) {
                callback(keyboardEvent);
            }
        });
    }
    Opti.bindShortcut = bindShortcut;
    function documentCss(element, object) {
        const selector = element.trim();
        if (!selector) {
            throw new Error("Selector cannot be empty.");
        }
        let styleTag = document.querySelector("style[js-styles]");
        if (!styleTag) {
            styleTag = document.createElement("style");
            styleTag.setAttribute("js-styles", "");
            document.head.appendChild(styleTag);
        }
        const sheet = styleTag.sheet;
        let ruleIndex = -1;
        const existingStyles = {};
        for (let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule && rule.selectorText === selector) {
                ruleIndex = i;
                const declarations = rule.style;
                for (let j = 0; j < declarations.length; j++) {
                    const name = declarations[j];
                    existingStyles[name] = declarations.getPropertyValue(name).trim();
                }
                break;
            }
        }
        if (!object || Object.keys(object).length === 0) {
            return existingStyles;
        }
        // Convert camelCase to kebab-case
        const newStyles = {};
        for (const [prop, val] of Object.entries(object)) {
            if (val !== null && val !== undefined) {
                const kebab = prop.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
                newStyles[kebab] = val.toString();
            }
        }
        const mergedStyles = Object.assign(Object.assign({}, existingStyles), newStyles);
        const styleString = Object.entries(mergedStyles)
            .map(([prop, val]) => `${prop}: ${val};`)
            .join(" ");
        if (ruleIndex !== -1) {
            sheet.deleteRule(ruleIndex);
        }
        try {
            sheet.insertRule(`${selector} { ${styleString} }`, sheet.cssRules.length);
        }
        catch (err) {
            console.error("Failed to insert CSS rule:", err, { selector, styleString });
        }
    }
    Opti.documentCss = documentCss;
    function createElementTree(node) {
        const el = document.createElement(node.tag);
        // Add class if provided
        if (node.class)
            el.className = node.class;
        // Add text content if provided
        if (node.text)
            el.textContent = node.text;
        // Add inner HTML if provided
        if (node.html)
            el.innerHTML = node.html;
        // Handle styles, ensure it’s an object
        if (node.style && typeof node.style === 'object') {
            for (const [prop, val] of Object.entries(node.style)) {
                el.style.setProperty(prop, val.toString());
            }
        }
        // Handle other attributes (excluding known keys)
        for (const [key, val] of Object.entries(node)) {
            if (key !== 'tag' &&
                key !== 'class' &&
                key !== 'text' &&
                key !== 'html' &&
                key !== 'style' &&
                key !== 'children') {
                if (typeof val === 'string') {
                    el.setAttribute(key, val);
                }
                else
                    throw new Opti.CustomException("ParameterError", "Custom parameters must be of type 'string'");
            }
        }
        // Handle children (ensure it's an array or a single child)
        if (node.children) {
            if (Array.isArray(node.children)) {
                node.children.forEach(child => {
                    el.appendChild(createElementTree(child));
                });
            }
            else {
                el.appendChild(createElementTree(node.children)); // Support for a single child node
            }
        }
        return el;
    }
    Opti.createElementTree = createElementTree;
    function $(selector) {
        return document.querySelector(selector);
    }
    Opti.$ = $;
    ;
    function $$(selector) {
        return document.querySelectorAll(selector);
    }
    Opti.$$ = $$;
    ;
})(Opti || (Opti = {}));
(function (Opti) {
    class HTMLElementCreator {
        constructor(tag, attrsOrPosition = {}) {
            this.parentStack = [];
            this.superEl = document.createDocumentFragment();
            if (tag instanceof HTMLElement) {
                this.currContainer = tag;
                this.superEl.append(tag);
            }
            else {
                const el = document.createElement(tag);
                this.makeElement(el, attrsOrPosition);
                this.currContainer = el;
                this.superEl.append(el);
            }
        }
        makeElement(el, attrs) {
            Object.entries(attrs).forEach(([key, value]) => {
                if (key === "text") {
                    el.textContent = value;
                }
                else if (key === "html") {
                    el.innerHTML = value;
                }
                else if (key === "class") {
                    if (typeof value === "string") {
                        el.classList.add(value);
                    }
                    else if (Array.isArray(value)) {
                        el.classList.add(...value.filter(c => typeof c === 'string' && c.trim()));
                    }
                }
                else if (key === "style") {
                    let styles = "";
                    Object.entries(value).forEach(([styleKey, styleValue]) => {
                        styles += `${toKebabCase(styleKey)}: ${styleValue}; `;
                    });
                    el.setAttribute("style", styles.trim());
                }
                else if (typeof value === "boolean") {
                    if (value)
                        el.setAttribute(key, "");
                    else
                        el.removeAttribute(key);
                }
                else if (value !== undefined && value !== null) {
                    el.setAttribute(key, value);
                }
            });
        }
        el(tag, attrs = {}) {
            const child = document.createElement(tag);
            this.makeElement(child, attrs);
            this.currContainer.appendChild(child);
            return this;
        }
        container(tag, attrs = {}) {
            const wrapper = document.createElement(tag);
            this.makeElement(wrapper, attrs);
            this.parentStack.push(this.currContainer);
            this.currContainer.appendChild(wrapper);
            this.currContainer = wrapper;
            return this;
        }
        up() {
            const prev = this.parentStack.pop();
            if (prev) {
                this.currContainer = prev;
            }
            return this;
        }
        append(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.append(this.superEl);
            }
        }
        prepend(to) {
            const target = typeof to === "string" ? document.querySelector(to) : to;
            if (target instanceof HTMLElement) {
                target.prepend(this.superEl);
            }
        }
        get element() {
            return this.currContainer;
        }
    }
    Opti.HTMLElementCreator = HTMLElementCreator;
    class Time {
        constructor(hours, minutes, seconds, milliseconds) {
            if (hours instanceof Date) {
                this.hours = hours.getHours();
                this.minutes = hours.getMinutes();
                this.seconds = hours.getSeconds();
                this.milliseconds = hours.getMilliseconds();
            }
            else {
                const now = new Date();
                this.hours = hours !== null && hours !== void 0 ? hours : now.getHours();
                this.minutes = minutes !== null && minutes !== void 0 ? minutes : now.getMinutes();
                this.seconds = seconds !== null && seconds !== void 0 ? seconds : now.getSeconds();
                this.milliseconds = milliseconds !== null && milliseconds !== void 0 ? milliseconds : now.getMilliseconds();
            }
            this.validateTime();
        }
        // Validation for time properties
        validateTime() {
            if (this.hours < 0 || this.hours >= 24)
                throw new SyntaxError("Hours must be between 0 and 23.");
            if (this.minutes < 0 || this.minutes >= 60)
                throw new SyntaxError("Minutes must be between 0 and 59.");
            if (this.seconds < 0 || this.seconds >= 60)
                throw new SyntaxError("Seconds must be between 0 and 59.");
            if (this.milliseconds < 0 || this.milliseconds >= 1000)
                throw new SyntaxError("Milliseconds must be between 0 and 999.");
        }
        static of(date) {
            return new this(date);
        }
        // Getters
        getHours() { return this.hours; }
        getMinutes() { return this.minutes; }
        getSeconds() { return this.seconds; }
        getMilliseconds() { return this.milliseconds; }
        // Setters
        setHours(hours) {
            this.hours = hours;
            this.validateTime();
        }
        setMinutes(minutes) {
            this.minutes = minutes;
            this.validateTime();
        }
        setSeconds(seconds) {
            this.seconds = seconds;
            this.validateTime();
        }
        setMilliseconds(milliseconds) {
            this.milliseconds = milliseconds;
            this.validateTime();
        }
        // Returns the time in milliseconds since the start of the day
        getTime() {
            return (this.hours * 3600000 +
                this.minutes * 60000 +
                this.seconds * 1000 +
                this.milliseconds);
        }
        // Returns the time in milliseconds since the start of the day
        static at(hours, minutes, seconds, milliseconds) {
            return new Time(hours, minutes, seconds, milliseconds).getTime();
        }
        sync() {
            return new Time();
        }
        // Static: Return current time as a Time object
        static now() {
            return new Time().getTime();
        }
        toString() {
            return `${this.hours.toString().padStart(2, '0')}:${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`;
            // removed by dead control flow
{}
        }
        toISOString() {
            return `T${this.toString()}.${this.milliseconds.toString().padStart(3, '0')}Z`;
        }
        toJSON() {
            return this.toISOString(); // Leverage the existing toISOString() method
        }
        toDate(years, months, days) {
            return new Date(years, months, days, this.hours, this.minutes, this.seconds, this.milliseconds);
        }
        static fromDate(date) {
            return new Time(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        // Arithmetic operations
        addMilliseconds(ms) {
            const totalMilliseconds = this.getTime() + ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        subtractMilliseconds(ms) {
            const totalMilliseconds = this.getTime() - ms;
            return Time.fromMilliseconds(totalMilliseconds);
        }
        addSeconds(seconds) {
            return this.addMilliseconds(seconds * 1000);
        }
        addMinutes(minutes) {
            return this.addMilliseconds(minutes * 60000);
        }
        addHours(hours) {
            return this.addMilliseconds(hours * 3600000);
        }
        // Static: Create a Time object from total milliseconds
        static fromMilliseconds(ms) {
            const hours = Math.floor(ms / 3600000) % 24;
            const minutes = Math.floor(ms / 60000) % 60;
            const seconds = Math.floor(ms / 1000) % 60;
            const milliseconds = ms % 1000;
            return new Time(hours, minutes, seconds, milliseconds);
        }
        // Parsing
        static fromString(timeString) {
            var _a, _b;
            const match = timeString.match(/^(\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{3}))?$/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt((_a = match[3]) !== null && _a !== void 0 ? _a : "0", 10);
                const milliseconds = parseInt((_b = match[4]) !== null && _b !== void 0 ? _b : "0", 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid time string format.");
        }
        static fromISOString(isoString) {
            const match = isoString.match(/T(\d{2}):(\d{2}):(\d{2})\.(\d{3})Z/);
            if (match) {
                const hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const seconds = parseInt(match[3], 10);
                const milliseconds = parseInt(match[4], 10);
                return new Time(hours, minutes, seconds, milliseconds);
            }
            throw new Error("Invalid ISO string format.");
        }
        // Comparison
        compare(other) {
            const currentTime = this.getTime();
            const otherTime = other.getTime();
            if (currentTime < otherTime) {
                return -1;
            }
            else if (currentTime > otherTime) {
                return 1;
            }
            else {
                return 0;
            }
        }
        isBefore(other) {
            return this.compare(other) === -1;
        }
        isAfter(other) {
            return this.compare(other) === 1;
        }
        equals(other) {
            return this.compare(other) === 0;
        }
        static equals(first, other) {
            return first.compare(other) === 0;
        }
    }
    Opti.Time = Time;
    class Sequence {
        constructor(tasks = []) {
            this.errorHandler = (error) => { throw new Error(error); };
            this.tasks = tasks;
        }
        // Executes the sequence, passing up to 3 initial arguments to the first task
        execute(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield this.tasks.reduce((prev, task) => prev.then((result) => task(result)), Promise.resolve(args));
                    return this.finalResult = result;
                }
                catch (error) {
                    return this.errorHandler(error);
                }
            });
        }
        result(callback) {
            if (callback) {
                return callback(this.finalResult);
            }
            return this.finalResult;
        }
        error(callback) {
            this.errorHandler = callback;
            return this;
        }
        // Static methods to create new sequences
        // Executes all tasks with the same arguments
        static of(...functions) {
            const tasks = [];
            for (const fn of functions) {
                if (fn instanceof Sequence) {
                    // Add the sequence's tasks
                    tasks.push(...fn.tasks);
                }
                else if (typeof fn === "function") {
                    // Add standalone functions
                    tasks.push(fn);
                }
                else {
                    throw new Error("Invalid argument: Must be a function or Sequence");
                }
            }
            return new Sequence(tasks);
        }
        // Executes tasks sequentially, passing the result of one to the next
        static chain(...functions) {
            return new Sequence(functions);
        }
        static parallel(...functions) {
            return new Sequence([() => Promise.all(functions.map((fn) => fn()))]);
        }
        static race(...functions) {
            return new Sequence([() => Promise.race(functions.map((fn) => fn()))]);
        }
        static retry(retries, task, delay = 0) {
            return new Sequence([
                () => new Promise((resolve, reject) => {
                    const attempt = (attemptNumber) => {
                        task()
                            .then(resolve)
                            .catch((error) => {
                            if (attemptNumber < retries) {
                                setTimeout(() => attempt(attemptNumber + 1), delay);
                            }
                            else {
                                reject(error);
                            }
                        });
                    };
                    attempt(0);
                }),
            ]);
        }
        // Instance methods for chaining
        add(...functions) {
            this.tasks.push(...functions);
            return this;
        }
    }
    Opti.Sequence = Sequence;
    class ShortcutEvent extends KeyboardEvent {
        constructor(keys, eventInit) {
            const lastKey = keys[keys.length - 1] || "";
            super("keydown", Object.assign(Object.assign({}, eventInit), { key: lastKey }));
            this.keys = keys;
        }
    }
    Opti.ShortcutEvent = ShortcutEvent;
    class FNRegistry {
        constructor() {
            this._map = {};
        }
        set(key, fn) {
            this._map[key] = fn;
        }
        get(key) {
            return this._map[key];
        }
    }
    Opti.FNRegistry = FNRegistry;
    class TypedMap {
        constructor() {
            this._map = {};
        }
        get size() {
            return Object.keys(this._map).length;
        }
        set(key, value) {
            this._map[key] = value;
        }
        get(key) {
            return this._map[key];
        }
        notNull(key) {
            return this._map[key] !== null || this._map[key] !== undefined;
        }
        delete(key) {
            delete this._map[key];
        }
        keys() {
            return Object.keys(this._map);
        }
        entries() {
            return Object.entries(this._map);
        }
        clear() {
            for (const key in this._map)
                delete this._map[key];
        }
        *[Symbol.iterator]() {
            for (const key in this._map) {
                yield [key, this._map[key]];
            }
        }
        get [Symbol.toStringTag]() {
            return "[object TypedMap]";
        }
        forEach(callback) {
            for (const key in this._map) {
                const val = this._map[key];
                callback(val, key);
            }
        }
    }
    Opti.TypedMap = TypedMap;
    let Crafty;
    (function (Crafty) {
        class Element {
            constructor(tag, props, children) {
                this.tag = tag;
                this.props = props !== null && props !== void 0 ? props : {};
                this.children = children !== null && children !== void 0 ? children : [];
            }
            getProp(prop) {
                return this.props[prop];
            }
            setProp(prop, value) {
                this.props[prop] = value;
            }
            getChildren() {
                return this.children;
            }
            append(child) {
                this.children = [...this.children, child];
            }
            prepend(child) {
                this.children = [child, ...this.children];
            }
            remove(child) {
                this.children = this.children.filter(c => c !== child);
            }
            render() {
                // your render implementation here
                throw new Error("Not implemented");
            }
        }
        Crafty.Element = Element;
        class Fragment extends Element {
        }
        Crafty.Fragment = Fragment;
    })(Crafty = Opti.Crafty || (Opti.Crafty = {}));
    class Enum {
        constructor(...values) {
            for (const val in values) {
                this[val] = Symbol();
            }
        }
        *[Symbol.iterator]() {
            for (const prop of Object.keys(this)) {
                yield prop;
            }
        }
    }
    Opti.Enum = Enum;
    class Collection {
        constructor(items) {
            this.items = items;
            this.length = items.length;
        }
        static from(arrayLike) {
            return new Collection(Array.from(arrayLike));
        }
        item(index) {
            var _a;
            return (_a = this.items[index]) !== null && _a !== void 0 ? _a : null;
        }
        each(callback, thisArg) {
            this.items.forEach(callback, thisArg);
        }
        *[Symbol.iterator]() {
            yield* this.items;
        }
        *entries() {
            yield* this.items.entries();
        }
        *keys() {
            yield* this.items.keys();
        }
        *values() {
            yield* this.items.values();
        }
    }
    Opti.Collection = Collection;
})(Opti || (Opti = {}));
function defineProperty(object, prop, getter, setter) {
    Object.defineProperty(object, prop, {
        get: getter,
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function defineGetter(object, prop, getter) {
    defineProperty(object, prop, getter);
}
function defineSetter(object, prop, setter) {
    Object.defineProperty(object, prop, {
        set: setter,
        enumerable: false,
        configurable: true
    });
}
function toArray(collection) {
    return Array.from(collection);
}
function toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function isGlobal(val) {
    return val === globalThis;
}
function typedEntries(obj) {
    return Object.entries(obj);
}
(function () {
    var _a;
    //@ts-ignore
    (_a = globalThis.Opti) !== null && _a !== void 0 ? _a : (globalThis.Opti = {});
    globalThis.f = (iife) => iife();
    globalThis.createEventListener = Opti.createEventListener;
    globalThis.Time = Opti.Time;
    globalThis.ShortcutEvent = Opti.ShortcutEvent;
    globalThis.isEmpty = Opti.isEmpty;
    globalThis.type = Opti.type;
    globalThis.generateID = Opti.generateID;
    globalThis.Colorize = Opti.Colorize;
    globalThis.Exception = Opti.Exception;
    globalThis.UnknownException = Opti.UnknownException;
    globalThis.NotImplementedException = Opti.NotImplementedException;
    globalThis.AccessException = Opti.AccessException;
    globalThis.CustomException = Opti.CustomException;
    globalThis.ColorizedSyntaxException = Opti.ColorizedSyntaxException;
    globalThis.RuntimeException = Opti.RuntimeException;
    globalThis.Enum = Opti.Enum;
    globalThis.Collection = Opti.Collection;
    Document.prototype.ready = Opti.ready;
    Document.prototype.leaving = Opti.leaving;
    Document.prototype.bindShortcut = Opti.bindShortcut;
    Document.prototype.css = Opti.documentCss;
    Document.prototype.createElementTree = Opti.createElementTree;
    NodeList.prototype.addEventListener = Opti.addEventListenerEnum;
    NodeList.prototype.addClass = Opti.addClassList;
    NodeList.prototype.removeClass = Opti.removeClassList;
    NodeList.prototype.toggleClass = Opti.toggleClassList;
    NodeList.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    HTMLCollection.prototype.addEventListener = Opti.addEventListenerEnum;
    HTMLCollection.prototype.addClass = Opti.addClassList;
    HTMLCollection.prototype.removeClass = Opti.removeClassList;
    HTMLCollection.prototype.toggleClass = Opti.toggleClassList;
    HTMLCollection.prototype.single = function () {
        return this.length > 0 ? this[0] : null;
    };
    EventTarget.prototype.addBoundListener = Opti.addBoundListener;
    EventTarget.prototype.addEventListeners = Opti.addEventListeners;
    EventTarget.prototype.delegateEventListener = Opti.delegateEventListener;
    Element.prototype.hasText = Opti.hasText;
    Element.prototype.txt = Opti.text;
    Element.prototype.addClass = Opti.addClass;
    Element.prototype.removeClass = Opti.removeClass;
    Element.prototype.toggleClass = Opti.toggleClass;
    Element.prototype.hasClass = Opti.hasClass;
    HTMLElement.prototype.css = Opti.css;
    HTMLElement.prototype.elementCreator = Opti.elementCreator;
    HTMLElement.prototype.tag = Opti.tag;
    HTMLElement.prototype.html = Opti.html;
    HTMLElement.prototype.show = Opti.show;
    HTMLElement.prototype.hide = Opti.hide;
    HTMLElement.prototype.toggle = Opti.toggle;
    HTMLFormElement.prototype.serialize = Opti.serialize;
    Node.prototype.parent = Opti.getParent;
    Node.prototype.ancestor = Opti.getAncestor;
    Node.prototype.getChildren = Opti.getChildren;
    Node.prototype.siblings = Opti.getSiblings;
    Node.prototype.$ = Opti.find;
    Node.prototype.$$ = Opti.findAll;
    Number.prototype.repeat = Opti.repeat;
    Array.prototype.unique = Opti.unique;
    Array.prototype.chunk = Opti.chunk;
    String.prototype.remove = Opti.remove;
    String.prototype.removeAll = Opti.removeAll;
    String.prototype.capitalize = Opti.capitalize;
    Math.random = Opti.random;
    JSON.parseFile = Opti.parseFile;
    Object.clone = Opti.clone;
    Object.forEach = Opti.forEach;
    Date.at = Opti.atDate;
    Date.fromTime = Opti.fromTime;
    defineGetter(Window.prototype, "width", () => window.innerWidth || document.body.clientWidth);
    defineGetter(Window.prototype, "height", () => window.innerHeight || document.body.clientHeight);
    defineGetter(HTMLElement.prototype, "visible", function () {
        return this.css("visibility") !== "hidden"
            ? this.css("display") !== "none"
            : Number(this.css("opacity")) > 0;
    });
})();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	__webpack_require__(366);
/******/ 	var __webpack_exports__ = __webpack_require__(688);
/******/ 	
/******/ })()
;
